
# 规划表单保存逻辑（三块：重点落实任务 / 体检任务 / 时序管理）

## 0. 前置约定（非常重要）
- 用户在表单里已经选择了“规划”，并能拿到：
  - 规划ID：schemeId（即规划的 `id`，会写入各业务表的 `scheme_id` 字段）
- 表单三块数据分别是：
  1) 重点落实任务（任务类型 / 建设内容 / 建设规模(量化) / XX年度目标）
  2) 体检任务（体检维度 / 指标项 / 存在问题 / 整改范围 / 整改内容）
  3) 时序管理（年度 / 阶段任务描述 / 阶段投资 / 操作）

> 所有落库建议在一个事务里完成：任何一块失败则整体回滚。


---

## 1. 重点落实任务（保存到哪些表？）
### 1.1 涉及的实际数据表
- 核心任务表：`t_scheme_task`（规划维度的任务主表，天然带 `scheme_id`）
- 年度目标/年度值表：`t_project_task`（按 `project_id + year` 存年度目标/投资/阶段值）

> 注意：`t_project_task` 只有 `project_id`，没有 `scheme_id`。
> 所以你必须从表单或业务上下文中拿到一个 `projectId`（通常是项目库 `t_project_base.id` 或上报库 `t_project_report.id`），用于写入年度目标/时序数据。


### 1.2 字段映射（表单字段 → 表.字段）
#### A) 重点落实任务：任务类型
- 重点落实任务.任务类型 → `t_scheme_task.task_type`
- 同时（用于年度目标对齐）→ `t_project_task.task_type`

#### B) 重点落实任务：建设内容
- 重点落实任务.建设内容 → `t_scheme_task.construct_content`
- 同时（用于年度目标对齐）→ `t_project_task.construct_content`

#### C) 重点落实任务：建设规模（量化）
- 重点落实任务.建设规模（量化） → `t_scheme_task.unit_target`

#### D) 重点落实任务：XX年度目标
- 重点落实任务.XX年度目标（输入的“年 + 值”）：
  - 年度（Year）→ `t_project_task.year`
  - 年度目标值（Value）→ `t_project_task.value`

#### E) 关联键（必须写）
- schemeId → `t_scheme_task.scheme_id`
- schemeName（若表单有）→ `t_scheme_task.scheme_name`
- projectId（必须有）→ `t_project_task.project_id`


### 1.3 保存流程（建议做法）
假设表单里是一组“重点落实任务”行：`keyTasks[]`，每行结构示例：
- task_type
- construct_content
- unit_target
- annualTargets[]: [{ year, value }]

#### Step 1：写入/更新 t_scheme_task（任务主数据）
- 新增：INSERT `t_scheme_task`
- 编辑：UPDATE `t_scheme_task`（用 id 定位）
- 删除：DELETE `t_scheme_task`（用 id）

> 建议你在 t_scheme_task 里保留 `id` 回填到前端，便于后续编辑。

**INSERT 示例**
```sql
INSERT INTO t_scheme_task (
  id, type, scheme_id, scheme_name,
  task_type, task_class, construct_content, unit_target,
  user_id, user_name, province, city, district,
  province_name, city_name, district_name
) VALUES (
  :id, :type, :schemeId, :schemeName,
  :taskType, :taskClass, :constructContent, :unitTarget,
  :userId, :userName, :province, :city, :district,
  :provinceName, :cityName, :districtName
);
````

#### Step 2：写入/更新 t_project_task（年度目标）

对每条重点落实任务的 annualTargets[]：

* 以 (project_id, year, task_type, construct_content) 为“唯一组合”进行 UPSERT（推荐）
* 操作=新增：INSERT
* 操作=编辑：UPDATE（按 id 或按唯一组合）
* 操作=删除：DELETE（按 id 或按唯一组合）

**UPSERT 思路（MySQL 示例：先查再改，或用唯一索引后 ON DUPLICATE KEY）**

```sql
INSERT INTO t_project_task (
  id, project_id, task_type, task_class, construct_content, year, value
) VALUES (
  :id, :projectId, :taskType, :taskClass, :constructContent, :year, :value
);
```

---

## 2. 体检任务（保存到哪些表？）

### 2.1 涉及的实际数据表

* 指标结果表（维度/指标项）：`t_scheme_problem_result`
* 问题项表（存在问题/整改范围）：`t_scheme_problem_item`
* 整改日志表（整改内容）：`t_scheme_problem_log`

> 它们都带 `scheme_id`，所以体检任务天然按规划保存，不需要 project_id。

### 2.2 字段映射（表单字段 → 表.字段）

#### A) 体检任务：体检维度

* 体检任务.体检维度 → `t_scheme_problem_result.class`

  * 说明：该字段在表里注释为“指标类别”，非常贴近“体检维度”

#### B) 体检任务：指标项

* 体检任务.指标项 → `t_scheme_problem_result.name`

#### C) 体检任务：存在问题

* 体检任务.存在问题 → `t_scheme_problem_item.problem_content`

#### D) 体检任务：整改范围

* 体检任务.整改范围 → `t_scheme_problem_item.probelm_scale`

#### E) 体检任务：整改内容

* 体检任务.整改内容 → `t_scheme_problem_log.msg`

#### F) 关联键（必须写）

* schemeId →

  * `t_scheme_problem_result.scheme_id`
  * `t_scheme_problem_item.scheme_id`
  * `t_scheme_problem_log.scheme_id`

#### G) 日志 parent_id 的归属（很关键）

* `t_scheme_problem_log.parent_id`：用于指向“某个问题/问题项”的父记录
* 推荐做法：

  * 让它指向 `t_scheme_problem_item.id`（更细粒度）
  * 或指向 `t_scheme_problem.id`（更粗粒度）
* 建议你统一成一种（更推荐指向 problem_item）

### 2.3 保存流程（建议做法）

假设表单里体检任务是一组行 `checkTasks[]`，每行结构示例：

* dimension（体检维度）
* indicator（指标项）
* problem_content（存在问题）
* probelm_scale（整改范围）
* rectify_msg（整改内容）

#### Step 1：保存指标结果（t_scheme_problem_result）

```sql
INSERT INTO t_scheme_problem_result (
  id, name, parents_id, parent_id, scheme_id,
  res, class, pre_year, nex_year, check_time, check_year,
  user_id, user_name, province, city, district,
  province_name, city_name, district_name
) VALUES (
  :id, :indicatorName, :parentsId, :parentId, :schemeId,
  :res, :dimensionClass, :preYear, :nexYear, :checkTime, :checkYear,
  :userId, :userName, :province, :city, :district,
  :provinceName, :cityName, :districtName
);
```

#### Step 2：保存问题项（t_scheme_problem_item）

```sql
INSERT INTO t_scheme_problem_item (
  id, name, parents_id, parent_id, problem_id, scheme_id,
  problem_content, probelm_scale,
  check_time, check_year, problem_status,
  user_id, user_name, province, city, district,
  province_name, city_name, district_name
) VALUES (
  :id, :name, :parentsId, :parentId, :problemId, :schemeId,
  :problemContent, :problemScale,
  :checkTime, :checkYear, :problemStatus,
  :userId, :userName, :province, :city, :district,
  :provinceName, :cityName, :districtName
);
```

#### Step 3：保存整改内容（t_scheme_problem_log）

```sql
INSERT INTO t_scheme_problem_log (
  id, parent_id, scheme_id,
  msg, action_rate, new_action_rate,
  action_material, new_action_material,
  update_time
) VALUES (
  :id, :problemItemId, :schemeId,
  :rectifyMsg, :actionRate, :newActionRate,
  :actionMaterial, :newActionMaterial,
  NOW()
);
```

---

## 3. 时序管理（保存到哪些表？）

### 3.1 涉及的实际数据表

* 时序/年度值表：`t_project_task`

> 该表字段天然符合：
>
> * year（年度）
> * construct_content（阶段任务描述）
> * value（阶段投资）
> * 操作（新增/编辑/删除）属于前端动作，不落库字段

### 3.2 字段映射（表单字段 → 表.字段）

* 时序管理.年度 → `t_project_task.year`
* 时序管理.阶段任务描述 → `t_project_task.construct_content`
* 时序管理.阶段投资 → `t_project_task.value`
* 时序管理.任务类型（若有）→ `t_project_task.task_type`
* 时序管理.任务中类（若有）→ `t_project_task.task_class`
* 关联键：projectId → `t_project_task.project_id`

### 3.3 保存流程（按“操作”执行）

假设表单 `timelineRows[]`，每行：

* year
* stage_task_desc
* stage_investment
* op: 'add' | 'edit' | 'delete'

#### op = add（新增一行）

```sql
INSERT INTO t_project_task (
  id, project_id, task_type, task_class, construct_content, year, value
) VALUES (
  :id, :projectId, :taskType, :taskClass, :stageTaskDesc, :year, :stageInvestment
);
```

#### op = edit（更新一行）

```sql
UPDATE t_project_task
SET
  task_type = :taskType,
  task_class = :taskClass,
  construct_content = :stageTaskDesc,
  year = :year,
  value = :stageInvestment
WHERE id = :id;
```

#### op = delete（删除一行）

```sql
DELETE FROM t_project_task WHERE id = :id;
```

---

## 4. 总体保存建议（一个事务，一次提交）

### 4.1 推荐的后端接口入参结构（示例）

```json
{
  "schemeId": "xxx",
  "schemeName": "xxx",
  "projectId": "xxx",
  "keyTasks": [
    {
      "id": "optional",
      "task_type": "...",
      "construct_content": "...",
      "unit_target": "...",
      "annualTargets": [
        { "year": 2026, "value": 100 },
        { "year": 2027, "value": 200 }
      ],
      "op": "add|edit|delete"
    }
  ],
  "checkTasks": [
    {
      "result": { "id": "optional", "class": "...", "name": "...", "check_year": 2026 },
      "item":   { "id": "optional", "problem_content": "...", "probelm_scale": "...", "op": "..." },
      "log":    { "id": "optional", "msg": "...", "op": "..." }
    }
  ],
  "timelineRows": [
    { "id": "optional", "year": 2026, "stage_task_desc": "...", "stage_investment": 300, "op": "..." }
  ]
}
```

### 4.2 事务内执行顺序（推荐）

1. 保存「重点落实任务」到 `t_scheme_task`
2. 保存「重点落实任务-年度目标」到 `t_project_task`（依赖 projectId）
3. 保存「体检任务」到：

   * `t_scheme_problem_result`
   * `t_scheme_problem_item`
   * `t_scheme_problem_log`
4. 保存「时序管理」到 `t_project_task`

---



