# 城市体检平台（前端）中台调用说明

本文档基于现有前端代码与同事提供的约定说明（[ai.txt](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/ai.txt)）整理，目标是让后续写页面的人知道：

- “中台”到底是怎么被前端调用的
- 参数怎么拼（model/args/field/join/order/group/page/limit）
- 什么时候用 `publicStore.http`，什么时候直接用 `api.xxx`

## 1. 调用链路（从页面到请求）

前端实际调用链路是：

1. 页面/组件里拼一个 `query` 对象（多数时候就是拼 SQL 片段字符串）
2. 调用 `publicStore.http({ Api: query })`（或 `Api1/Api2/...` 并发）
3. `publicStore.http` 会把 key 映射到 `api/index.ts` 里的同名方法（例如 `Api` → `api.Api`）
4. `api/index.ts` 最终调用 axios 封装 `request`（[request.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/utils/request.ts)）

对应关键文件：

- axios 封装与拦截器：[request.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/utils/request.ts)
- API 方法表（中台 query/add/upd/del 在这里）：[api/index.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/api/index.ts#L336-L551)
- store 聚合并发入口（你页面里最常用的）：[publicStore.http](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/stores/publicStore.ts#L149-L177)

## 2. `publicStore.http` 怎么用（最重要）

签名（来自实现）：

```ts
publicStore.http(contxt, url?, headers?, method?)
```

### 2.1 contxt：用 key 选择要调哪个 API

`contxt` 是一个对象，它的每个 key 都会被当成 `api/index.ts` 里的方法名来调用。

```ts
await publicStore.http({
  Api: { model: 't_scheme_project', args: "status='0'", field: 'id,name' }
})
```

并发多个请求（常用于：列表 + COUNT(*) 总数）：

```ts
const res = await publicStore.http({
  Api1: { ...query, page: 1, limit: 20 },
  Api2: { ...query, field: 'COUNT(*)' }
})
```

### 2.2 url / headers / method：覆盖默认请求

默认情况下 `api.xxx` 自己有默认 URL；如果想覆盖，可以在 `http` 的第二个参数传入：

- 字符串：所有 key 共用该 URL
- 对象：按 key 指定不同 URL

示例：刷新 CSRF Token（GET）：

```ts
await publicStore.http({ Api: {} }, '/api/v1/terminal/base/csrfToken', {}, 'get')
```

### 2.3 返回值规则（坑点：会“抽取 data”）

`publicStore.http` 不会把完整响应体返回给页面，它会做一次抽取：

- 优先返回 `res.data`
- 否则返回 `res.respond`
- 再否则返回 `[]`

所以：

- 用 `publicStore.http` 通常拿到的是“数组/对象数据本体”（比如查询结果数组）
- 如果你要判断 `code/msg`，更建议直接用 `api.xxx(...)`（见第 5 节）

实现位置：[publicStore.http](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/stores/publicStore.ts#L149-L176)。

### 2.4 `_xxx` 写入公共缓存 `_public`

如果 key 以 `_` 开头（例如 `_stations`），结果会额外写入 `publicStore._public.stations`，并且返回对象里 key 会去掉 `_`。

适合做“全局缓存一次、多处复用”的公共数据。

## 3. 中台接口（`/terminal/middle/*`）对应的前端方法

前端把“中台”抽象成了这些 API 方法（默认 URL 如下）：

- 查询（拼 SQL）：`Api/Api1/Api2/Api3/Api4/Api5` → `/api/v1/terminal/middle/query`
- 新增：`addApi/addApi1` → `/api/v1/terminal/middle/add`
- 更新：`updApi/updApi1` → `/api/v1/terminal/middle/upd`
- 删除：`delApi/delApi1` → `/api/v1/terminal/middle/del`
- 日志：`logApi` → `/api/v1/terminal/middle/log`

定义位置：[api/index.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/api/index.ts#L427-L551)。

## 4. 查询参数约定（model/args/field/join/order/group）

同事提供的约定（[ai.txt](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/ai.txt)）在代码里就是这么用的：

- model：form / FROM 部分（表名或带别名）
- args：WHERE 部分（字符串拼接）
- field：SELECT 部分（逗号分隔字段）
- join：LEFT JOIN 部分（字符串）
- order：ORDER BY 部分（字符串）
- group：GROUP BY 部分（字符串）
- page、limit：分页（常见写法：列表请求带 page/limit，总数请求 field=COUNT(*)）

### 4.1 最小示例（查表）

```ts
const query = {
  model: 't_scheme_project',
  field: 'id,name',
  args: "status='0'"
}
const rows = await publicStore.http({ Api: query })
```

### 4.2 join + 动态 where + 分页 + COUNT(*)（真实页面示例）

页面：[actionRelease/index.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/views/async/actionRelease/index.vue#L176-L207)

- `model: 't_scheme_project p'`
- `join: 't_scheme_plan sp ON p.scheme_id = sp.id'`
- `args` 通过 `+=` 拼接 province/city/时间/搜索等条件
- `Api1` 查列表（带 page/limit）
- `Api2` 查总数（`field: 'COUNT(*)'`）

### 4.3 group 聚合（真实页面示例）

页面：[planManagerCity/m1.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/views/async/planManagerCity/m1.vue#L236-L245)

- `model: 't_scheme_design'`
- `field: 'parent_id, COUNT(*) AS design_num'`
- `args: 'parent_id IN (...)'`
- `group: 'parent_id'`

## 5. 新增/修改/删除怎么做（两种写法）

### 5.1 直接用 `api.addApi/updApi/delApi`（推荐：能拿到 code/msg）

通用 payload 形态在多个地方一致（例如 [Add.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/components/Add.vue#L272-L312)）：

```ts
const params = { model: 't_xxx', list: [form] }
const res = await api.updApi(params)
if (res.code === 200) {
  // 成功
} else {
  // res.msg
}
```

### 5.2 用 `publicStore.http` 并发新增/删除（适合批量、多表联动）

示例：一次请求里做两个新增（项目表 + 任务表），来自 [StepFoot.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/components/StepFoot.vue#L141-L168)：

```ts
const res = await publicStore.http({
  addApi:  { model: 't_scheme_project', list: addProject },
  addApi1: { model: 't_scheme_task',    list: addTask }
})
```

注意：这种写法返回的是 `res.data` 抽取后的结果，通常拿不到 `code/msg`，更适合“尽力而为 + 不需要精细错误处理”的批量操作。

## 6. 其他常用“非中台”接口（也走同一套封装）

除了 `/terminal/middle/*` 以外，代码里也大量通过同一套 `api + publicStore.http` 调这些：

- CSRF token：`GET /api/v1/terminal/base/csrfToken`（[permission.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/router/permission.ts#L22-L25)）
- 登录：`POST /api/v1/terminal/user/login`（[login/index.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/views/async/login/index.vue#L133-L201)）
- 图片验证码：`POST /api/v1/terminal/user/code`（同上文件）
- 文件删除：`POST /api/v1/terminal/base/deleteFile`（[Step1.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/components/Step1.vue#L198-L235)）
- 文件转移：`POST /api/v1/terminal/base/changeFile`（[StepFoot.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/components/StepFoot.vue#L133-L139)）
- redis set/get：`setApi/getApi` → `/api/v1/terminal/high/*`（例如 [Add.vue](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/components/Add.vue#L315-L327)）

## 7. 请求拦截：鉴权/动态地址/CSRF/加密

### 7.1 动态 baseURL（开发/生产/切 IP）

每次请求会在拦截器里通过 `getHttp(req)` 动态计算 `baseURL`（见 [request.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/utils/request.ts#L18-L41) + [common.ts#getHttp](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/utils/common.ts#L36-L63)）。

优先级大致是：

1. `req.headers.ip`（单次请求临时指定）
2. `configStore().ip`（手动切换的动态 IP）
3. 生产环境 `configStore().produrl`
4. 生产环境默认 `window.location.origin`
5. 开发环境默认空字符串（走 vite 代理/同源）

### 7.2 头部：Authorization / CSRF / AuthToken

请求拦截器会自动写入：

- `Authorization: configStore().token`
- `X-CSRF-Token: configStore().csrfToken`
- `AuthToken: xyz + encrypt(...)`（和 `secret_key` 相关）

见 [request.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/utils/request.ts#L18-L41)。

### 7.3 CSRF 过期自动刷新

如果响应是 403 且 `msg === 'CSRF token invalid'`，会自动：

1. 把原请求加入队列
2. 调 `/api/v1/terminal/base/csrfToken` 刷新
3. 刷新成功后重放队列里的请求

逻辑见：[request.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/utils/request.ts#L95-L139)。

### 7.4 “终端接口”加解密

当配置满足条件且 URL 包含 `/terminal` 时，会对请求体做加密（`Content-Type: text/plain`），响应为字符串时解密。

见：[request.ts](file:///c:/Users/Pro13/Desktop/%E5%8D%95%E5%AD%90/%E7%9F%A5%E8%AF%86%E5%BA%93/doc/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9F%8E%E5%B8%82%E4%BD%93%E6%A3%80%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/om/om/coworker/city/vue/src/utils/request.ts#L32-L58)。

## 8. 实操建议（写业务页面时怎么选）

- 查列表/统计：优先 `publicStore.http({ Api/Api1/Api2: query })`，写起来最省事
- 严格判断成功失败（需要 `code/msg`）：直接用 `api.addApi/updApi/delApi/loginApi...`
- 多请求并发：用 `publicStore.http({ Api1: q1, Api2: q2, ... })`
- 注意 `args` 是字符串拼接：尽量保证引号、LIKE、IN 拼接规范，避免拼错导致 SQL 报错

