<br />

***

# Implementation Plan: Save “Three Domains” Data (Key Tasks, Physical Examination, Timing) from Step2 Form

## 1. Goal

Implement a reliable saving workflow in `step2.vue` to persist form data into the actual database tables representing:

1. **Key Implementation Tasks (重点落实任务)**
2. **Physical Examination Tasks (体检任务)**
3. **Timing Management (时序管理)**

Even though the business concept is “three tables”, actual persistence spans multiple tables.

## 2. Confirmed Facts & Assumptions

* **`scheme_id`** **is the Scheme ID** and is the primary link key for scheme-level persistence.
* Timing-related persistence requires a `project_id` in `t_project_task`, but it is unclear whether `project_id` should reference:
  * `t_project_base.id` OR
  * `t_project_report.id`
* **Most robust method:** persist timing rows to **both** sources if we can resolve IDs from both tables.

## 3. Data Mapping (Field → Table.Column)

### 3.1 Key Implementation Tasks (重点落实任务)

**Form fields**

* Task Type
* Construction Content
* Quantified Target (Construction Scale)
* Annual Targets (Year → Value)

**Persistence**

* **Key task definition** → `t_scheme_task`
* **Annual targets** → `t_project_task` (requires `project_id`)

**Mapping**

* Key Task: “Task Type” → `t_scheme_task.task_type`
* Key Task: “Construction Content” → `t_scheme_task.construct_content`
* Key Task: “Quantified Target (Scale)” → `t_scheme_task.unit_target`
* Key Task: `scheme_id` → `t_scheme_task.scheme_id`

Annual Targets:

* Annual Target: “Year” → `t_project_task.year`
* Annual Target: “Target Value” → `t_project_task.value`
* Annual Target: “Task Type” → `t_project_task.task_type` (denormalized for query convenience)
* Annual Target: “Construction Content” → `t_project_task.construct_content` (denormalized for query convenience)
* Annual Target: “Project ID” → `t_project_task.project_id` (resolved from base/report projects)

***

### 3.2 Physical Examination Tasks (体检任务)

**Form fields**

* Check Dimension
* Indicator Item
* Problem Found
* Rectification Scope
* Rectification Content

**Persistence**

* Indicator results → `t_scheme_problem_result`
* Problem item → `t_scheme_problem_item`
* Rectification log → `t_scheme_problem_log`

**Mapping**

* Check: “Dimension” → `t_scheme_problem_result.class`
* Check: “Indicator Item” → `t_scheme_problem_result.name`
* Check: `scheme_id` → `t_scheme_problem_result.scheme_id`
* Check: “Problem Found” → `t_scheme_problem_item.problem_content`
* Check: “Rectification Scope” → `t_scheme_problem_item.probelm_scale`
* Check: `scheme_id` → `t_scheme_problem_item.scheme_id`
* Check: “Rectification Content” → `t_scheme_problem_log.msg`
* Check: `scheme_id` → `t_scheme_problem_log.scheme_id`
* Check: `t_scheme_problem_log.parent_id` → recommended to store the created `t_scheme_problem_item.id` for tight linkage

> If Step2 currently does not expose these physical examination inputs, implement the saving function to accept an optional `checkTasks[]`. If empty, skip safely.

***

### 3.3 Timing Management (时序管理)

**Form fields**

* Year
* Stage Task Description
* Stage Investment
* Operation (Add/Edit/Delete)

**Persistence**

* Timing rows → `t_project_task`

**Mapping**

* Timing: “Year” → `t_project_task.year`
* Timing: “Stage Task Description” → `t_project_task.construct_content`
* Timing: “Stage Investment” → `t_project_task.value`
* Timing: “Project ID” → `t_project_task.project_id`

Operation handling:

* Add → INSERT `t_project_task`
* Edit → UPDATE by `id` (or unique composite key)
* Delete → DELETE by `id` (preferred) or by unique key

***

## 4. Robust Project ID Resolution Strategy (Write to BOTH)

Because we don’t know whether `t_project_task.project_id` points to base or report, we will:

1. Resolve **Base project IDs**: `SELECT id FROM t_project_base WHERE scheme_id = :scheme_id`
2. Resolve **Report project IDs**: `SELECT id FROM t_project_report WHERE scheme_id = :scheme_id`
3. Persist timing/annual rows to:
   * All resolved base IDs AND
   * All resolved report IDs
4. Add an **audit marker** to help future cleanup:
   * If the schema has no “source” column, we include source in a safe denormalized field when possible, e.g. prefix `construct_content`:
     * `[BASE] ...` and `[REPORT] ...`
   * If modifying data is undesirable, store an external log entry client-side or backend logging.

> If duplication becomes an issue later, we can clean by choosing the correct source once clarified.

***

## 5. Implementation Steps in `step2.vue`

### 5.1 Add a single orchestrator function

Create `async function saveThreeDomains(payload)` in `<script setup>`.

Payload:

```
type SavePayload = {
  schemeId: string;       // scheme_id (confirmed)
  schemeName?: string;
  keyTask?: {
    taskType?: string;
    taskClass?: string;
    constructContent?: string;
    unitTarget?: string;  // quantified target
    annualTargets?: Array<{ year: number; value: number; op?: 'add'|'edit'|'delete'; id?: string }>;
  };
  timelineRows?: Array<{ year: number; desc: string; investment: number; op: 'add'|'edit'|'delete'; id?: string }>;
  checkTasks?: Array<{
    dimension: string;
    indicator: string;
    problemFound: string;
    rectifyScope: string;
    rectifyContent: string;
    checkYear?: number;
  }>;
};

```

### 5.2 Execute in a strict order (best-effort atomicity)

Run **after the main “report” save succeeds**, and ensure `await`:

1. Save **Key Task** to `t_scheme_task` (if present)
2. Resolve project IDs (base + report) by `scheme_id`
3. Save **Annual Targets** to `t_project_task` for each resolved project ID
4. Save **Timing Rows** to `t_project_task` for each resolved project ID
5. Save **Physical Examination** to `t_scheme_problem_*` (if provided)

### 5.3 Error handling policy

* If main report save succeeds but three-domain saving fails:
  * Show user a clear warning: “Main record saved; extended records failed.”
  * Log full error details.
  * Optionally provide a “Retry Save Extended Data” button.

***

## 6. API Usage (Data Middle Platform Style)

Use your existing `api.addApi` / `api.editApi` / `api.delApi` (or `publicStore.http`) with model names:

* `t_scheme_task`
* `t_project_task`
* `t_scheme_problem_result`
* `t_scheme_problem_item`
* `t_scheme_problem_log`

Recommended operations:

* For inserts: generate `id` using `uuidv6()`.
* For edits/deletes: rely on server-returned IDs stored in row models.

***

## 7. Acceptance Criteria (What “Done” Means)

1. After a user saves Step2 successfully:
   * A row exists in `t_scheme_task` with `scheme_id = selected scheme_id` (when keyTask provided)
2. Timing rows exist in `t_project_task` for:
   * all base project IDs found by `scheme_id`, AND
   * all report project IDs found by `scheme_id`
3. If physical examination data is provided:
   * rows exist in `t_scheme_problem_result`, `t_scheme_problem_item`, and `t_scheme_problem_log` linked by `scheme_id`
4. No blocking UI issues; failures are visible and recoverable.

***

## 8. Risks & Mitigations

**Risk:** Duplicated timing rows because we save to both base and report IDs\
**Mitigation:** Add a source marker or log; later clean up after business confirms correct source.

**Risk:** Physical examination fields not present in UI\
**Mitigation:** Implement optional `checkTasks[]` support; skip safely when empty.

***

